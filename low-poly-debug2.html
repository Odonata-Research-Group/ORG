<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ORG — Low Poly Debug 2</title>
<style>
  body { background: #080808; color: #eeeae2; font-family: monospace; padding: 40px; }
  #log { margin-top: 20px; font-size: 11px; line-height: 2; color: #666; }
  #log span { display: block; }
  #log .ok { color: #39ff14; }
  #log .err { color: #ff3020; }
  canvas { border: 1px solid #333; margin-top: 20px; display: block; }
  button { background: #eeeae2; color: #080808; border: none; padding: 10px 24px; font-family: monospace; cursor: pointer; }
  input { display: none; }
</style>
</head>
<body>
<button onclick="document.getElementById('fi').click()">Upload Image</button>
<input type="file" id="fi" accept="image/*">
<div id="log"></div>
<canvas id="c"></canvas>

<script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
<script>
const log = t => {
  const s = document.createElement('span');
  s.className = t.startsWith('ERR') ? 'err' : 'ok';
  s.textContent = t;
  document.getElementById('log').appendChild(s);
};

document.getElementById('fi').addEventListener('change', e => {
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      log('Image: ' + img.width + 'x' + img.height);
      run(img);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

function run(img) {
  const W = 400, H = Math.round(img.height * (400/img.width));

  const off = document.createElement('canvas');
  off.width = W; off.height = H;
  const octx = off.getContext('2d');
  octx.drawImage(img, 0, 0, W, H);
  const imgData = octx.getImageData(0, 0, W, H);

  // Generate points — add small random jitter to every point
  // to prevent collinear/coincident issues
  const pts = [];
  const jitter = () => (Math.random() - 0.5) * 0.01;

  // Corners with tiny jitter
  pts.push([1 + jitter(),       1 + jitter()]);
  pts.push([W - 2 + jitter(),   1 + jitter()]);
  pts.push([1 + jitter(),       H - 2 + jitter()]);
  pts.push([W - 2 + jitter(),   H - 2 + jitter()]);
  pts.push([W/2 + jitter(),     1 + jitter()]);
  pts.push([1 + jitter(),       H/2 + jitter()]);
  pts.push([W - 2 + jitter(),   H/2 + jitter()]);
  pts.push([W/2 + jitter(),     H - 2 + jitter()]);

  // Random interior points
  for (let i = 0; i < 300; i++) {
    pts.push([
      2 + Math.random() * (W - 4) + jitter(),
      2 + Math.random() * (H - 4) + jitter()
    ]);
  }

  log('Points: ' + pts.length);

  // Log first few points to check for issues
  log('First 3 pts: ' + pts.slice(0,3).map(p => p[0].toFixed(2)+','+p[1].toFixed(2)).join(' | '));

  const coords = new Float64Array(pts.length * 2);
  for (let i = 0; i < pts.length; i++) {
    coords[i*2]   = pts[i][0];
    coords[i*2+1] = pts[i][1];
  }

  let d;
  try {
    d = Delaunator.from(coords);
  } catch(e) {
    log('ERR Delaunator.from: ' + e.message);
    return;
  }

  const triCount = d.triangles.length / 3;
  log('Triangles: ' + triCount);

  if (triCount === 0) {
    log('ERR: still 0 triangles');
    // Try Delaunator.from with array of arrays instead
    log('Trying array-of-arrays format...');
    try {
      const d2 = Delaunator.from(pts);
      log('Array-of-arrays triangles: ' + d2.triangles.length/3);
    } catch(e) {
      log('ERR array-of-arrays: ' + e.message);
    }
    return;
  }

  // Render
  const c = document.getElementById('c');
  c.width = W; c.height = H;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#080808';
  ctx.fillRect(0, 0, W, H);

  for (let i = 0; i < d.triangles.length; i += 3) {
    const ai = d.triangles[i], bi = d.triangles[i+1], ci = d.triangles[i+2];
    const ax = coords[ai*2], ay = coords[ai*2+1];
    const bx = coords[bi*2], by = coords[bi*2+1];
    const cx = coords[ci*2], cy = coords[ci*2+1];
    const mx = (ax+bx+cx)/3, my = (ay+by+cy)/3;
    const px = Math.max(0,Math.min(W-1,Math.round(mx)));
    const py = Math.max(0,Math.min(H-1,Math.round(my)));
    const idx = (py*W+px)*4;
    const r=imgData.data[idx], g=imgData.data[idx+1], b=imgData.data[idx+2];
    const v = Math.round(r*0.299+g*0.587+b*0.114);
    ctx.beginPath();
    ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(cx,cy);
    ctx.closePath();
    ctx.fillStyle = `rgb(${v},${v},${v})`;
    ctx.fill();
    ctx.strokeStyle = 'rgba(8,8,8,0.5)';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
  log('Done!');
}
</script>
</body>
</html>
